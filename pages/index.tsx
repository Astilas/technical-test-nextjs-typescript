import Head from "next/head";
import { Layout } from "../components/Layout";

import { Pokemon } from "../interfaces/pokemon";
import { useEffect, useMemo, useState } from "react";
import { calculatePower } from "../utils/calculatePower";
import { filterPokemon } from "../utils/filterPokemon";
import {
  TableContainer,
  Table,
  Tr,
  Th,
  Td,
  TypeBadge,
  TypeContainer,
  FilterContainer,
  Label,
  Input,
  StatsContainer,
} from "../styles/pokemons";
import { useRouter } from "next/router";
import { GetServerSidePropsContext } from "next";

const HomePage = ({ pokemons }: { pokemons: Pokemon[] }) => {
  const router = useRouter();

  const [filters, setFilters] = useState({
    name: router.query.search ? String(router.query.search) : "",
    power: router.query.power ? String(router.query.power) : "0",
  });

  // Update filters
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;

    setFilters((prev) => ({
      ...prev,
      [name]: value,
    }));

    // Update URL
    const query: { [key: string]: string } = {};
    if (name === "name" && value) query.search = value;
    if (name === "power" && value !== "" && value !== "0") query.power = value;
    if (name !== "name" && filters.name) query.search = filters.name;
    if (name !== "power" && filters.power !== "" && filters.power !== "0")
      query.power = filters.power;

    router.push(
      {
        pathname: "/",
        query: Object.keys(query).length > 0 ? query : undefined,
      },
      undefined,
      { shallow: true }
    );
  };

  // Filter pokemons by name and power
  const filteredPokemon = useMemo(() => {
    return filterPokemon(pokemons, filters.name, filters.power);
  }, [pokemons, filters]);

  // Sync filters with URL params on navigation (e.g., back button)
  useEffect(() => {
    const { search = "", power = "0" } = router.query;
    setFilters({
      name: search as string,
      power: power as string,
    });
  }, [router.query]);

  // Calculate count, min, max based on the power filter
  const powerStats = useMemo(() => {
    const powerValue =
      filters.power.trim() === "" ? 0 : parseInt(filters.power);
    if (isNaN(powerValue)) return { count: 0, min: null, max: null };

    const filteredByPower = filteredPokemon.filter(
      (pokemon: Pokemon) => pokemon.power! > powerValue
    );

    if (filteredByPower.length === 0) {
      return { count: 0, min: "none", max: "none" };
    }

    const powerValues: number[] = filteredByPower.map(
      (pokemon: Pokemon) => pokemon.power!
    );

    return {
      count: filteredByPower.length,
      min: Math.min(...powerValues),
      max: Math.max(...powerValues),
    };
  }, [filters.power, filteredPokemon]);

  return (
    <>
      <Head>
        <title>Technical test next.js and typescript</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <h1>Pokemon list</h1>

      <FilterContainer>
        <Label>Search:</Label>
        <Input
          type="text"
          placeholder="Search Pokemon by name"
          name="name"
          value={filters.name}
          onChange={handleInputChange}
        />
        <Label>Power threshold:</Label>
        <Input
          type="number"
          placeholder="search by power greater than"
          name="power"
          min="0"
          value={filters.power}
          onChange={handleInputChange}
        />
        <StatsContainer>
          <div>Count over threshold: {powerStats.count}</div>
          <div>Min: {powerStats.min}</div>
          <div>Max: {powerStats.max}</div>
        </StatsContainer>
      </FilterContainer>
      <TableContainer>
        <Table>
          <thead>
            <tr>
              <Th>ID</Th>
              <Th>Nom</Th>
              <Th>Type</Th>
              <Th>HP</Th>
              <Th>Attaque</Th>
              <Th>Défense</Th>
              <Th>Attaque Spéciale</Th>
              <Th>Défense Spéciale</Th>
              <Th>Vitesse</Th>
              <Th>Puissance</Th>
            </tr>
          </thead>
          <tbody>
            {filteredPokemon.length > 0 ? (
              filteredPokemon.map((pokemon: Pokemon) => (
                <Tr
                  key={pokemon.id}
                  onClick={() => router.push(`/pokemon/${pokemon.id}`)}
                  style={{ cursor: "pointer" }}
                >
                  <Td data-label="ID">{pokemon.id}</Td>
                  <Td data-label="Nom">{pokemon.name}</Td>
                  <Td data-label="Type">
                    <TypeContainer>
                      {pokemon.type.map((type: string) => (
                        <TypeBadge key={type} pokemonType={type}>
                          {type}
                        </TypeBadge>
                      ))}
                    </TypeContainer>
                  </Td>
                  <Td data-label="HP">{pokemon.hp}</Td>
                  <Td data-label="Attaque">{pokemon.attack}</Td>
                  <Td data-label="Défense">{pokemon.defense}</Td>
                  <Td data-label="Attaque Spéciale">
                    {pokemon.special_attack}
                  </Td>
                  <Td data-label="Défense Spéciale">
                    {pokemon.special_defense}
                  </Td>
                  <Td data-label="Vitesse">{pokemon.speed}</Td>
                  <Td data-label="Puissance">{pokemon.power}</Td>
                </Tr>
              ))
            ) : (
              <tr>
                <Td colSpan={10}>No Pokemon found</Td>
              </tr>
            )}
          </tbody>
        </Table>
      </TableContainer>
    </>
  );
};

HomePage.getLayout = Layout;

export async function getServerSideProps(context: GetServerSidePropsContext) {
  try {
    const query = context.params || {};
    const search = query.search || "";
    const power = query.power || "0";
    const res = await fetch("http://localhost:3000/api/pokemons");
    const pokemons = await res.json();

    if (pokemons.length === 0) {
      throw new Error("No pokemon found");
    }

    // Add power to each pokemon
    const pokemonsWithPower = pokemons.map((pokemon: Pokemon) => ({
      ...pokemon,
      power: calculatePower(pokemon),
    }));

    // Apply filters
    const filteredPokemons = filterPokemon(
      pokemonsWithPower,
      search as string,
      power as string
    );

    return {
      props: {
        pokemons: filteredPokemons,
      },
    };
  } catch (error) {
    console.error("Erreur lors de la récupération des données Pokémon:", error);
    return {
      notFound: true,
    };
  }
}

export default HomePage;
