import Head from "next/head";
import { Layout } from "../components/Layout";

import { Pokemon } from "../interfaces/pokemon";
import { useMemo, useState } from "react";
import { calculatePower } from "../utils/calculatePower";
import Link from "next/link";
import { TableContainer, Table, Tr, Th, Td, TypeBadge, TypeContainer } from "../styles/pokemons";

const HomePage = ({ pokemons }: { pokemons: Pokemon[] }) => {
  const [filters, setFilters] = useState({
    name: "",
    power: "0",
  });

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;

    setFilters((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  // Filter pokemons by name and power
  const filteredPokemon = useMemo(() => {
    return pokemons.filter((pokemon) => {
      const nameMatch = pokemon.name
        .toLowerCase()
        .includes(filters.name.toLowerCase());
      const powerMatch =
        filters.power.trim() === "" || pokemon.power! > parseInt(filters.power);

      if (filters.name && filters.power.trim() !== "") {
        // If searching by name and power, return all pokemon that match the name
        return nameMatch;
      } else {
        // Otherwise, we apply both filters
        return nameMatch && powerMatch;
      }
    });
  }, [pokemons, filters.name, filters.power]);

  // Calculate count, min, max based on the power filter
  const powerStats = useMemo(() => {
    const powerValue =
      filters.power.trim() === "" ? 0 : parseInt(filters.power);
    if (isNaN(powerValue)) return { count: 0, min: null, max: null };

    // Calculer les stats de power uniquement (pas de filtrage visuel)
    const filteredByPower = filteredPokemon.filter(
      (pokemon) => pokemon.power! > powerValue
    );

    if (filteredByPower.length === 0) {
      return { count: 0, min: "none", max: "none" };
    }

    const powerValues: number[] = filteredByPower.map(
      (pokemon) => pokemon.power!
    );

    return {
      count: filteredByPower.length,
      min: Math.min(...powerValues),
      max: Math.max(...powerValues),
    };
  }, [filters.power, filteredPokemon]);

  return (
    <>
      <Head>
        <title>Technical test next.js and typescript</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <h1>Pokemon list</h1>

      <div>
        <div>Search</div>
        <input
          type="text"
          placeholder="search by name"
          name="name"
          value={filters.name}
          onChange={(e) => handleInputChange(e)}
        />
        <div>Power threshold</div>
        <input
          type="number"
          placeholder="search by power greater than"
          name="power"
          min="0"
          value={filters.power}
          onChange={(e) => handleInputChange(e)}
        />
        <div>Count over threshold: {powerStats.count}</div>
        <div>Min: {powerStats.min}</div>
        <div>Max: {powerStats.max}</div>
      </div>
      <TableContainer>
        <Table>
          <thead>
            <tr>
              <Th>ID</Th>
              <Th>Nom</Th>
              <Th>Type</Th>
              <Th>HP</Th>
              <Th>Attaque</Th>
              <Th>Défense</Th>
              <Th>Attaque Spéciale</Th>
              <Th>Défense Spéciale</Th>
              <Th>Vitesse</Th>
              <Th>Puissance</Th>
            </tr>
          </thead>
          <tbody>
            {filteredPokemon.map((pokemon: Pokemon) => (
              <Link href={`/pokemon/${pokemon.id}` } key={pokemon.id}>
                
              <Tr>
                <Td data-label="ID">{pokemon.id}</Td>
                <Td data-label="Nom">
                  
                   {pokemon.name}
                </Td>
                <Td data-label="Type">
                <TypeContainer>
                  {pokemon.type.map((type) => (
                    <TypeBadge key={type} pokemonType={type}>
                      {type}
                    </TypeBadge>
                  ))}
                </TypeContainer>
                </Td>
                <Td data-label="HP">{pokemon.hp}</Td>
                <Td data-label="Attaque">{pokemon.attack}</Td>
                <Td data-label="Défense">{pokemon.defense}</Td>
                <Td data-label="Attaque Spéciale">{pokemon.special_attack}</Td>
                <Td data-label="Défense Spéciale">{pokemon.special_defense}</Td>
                <Td data-label="Vitesse">{pokemon.speed}</Td>
                <Td data-label="Puissance">{pokemon.power}</Td>
              </Tr>

              </Link>
            ))}
          </tbody>
        </Table>
      </TableContainer>
    </>
  );
};

HomePage.getLayout = Layout;

export async function getStaticProps() {
  try {
    const pokemons = await fetch("http://localhost:3000/api/pokemons").then(
      (resp) => resp.json()
    );

    if (pokemons.length === 0) {
      throw new Error("No pokemon found");
    }

    // Add power to each pokemon
    const pokemonsWithPower = pokemons.map((pokemon: any) => ({
      ...pokemon,
      power: calculatePower(pokemon),
    }));

    return {
      props: {
        pokemons: pokemonsWithPower,
      },
      revalidate: 3600,
    };
  } catch (error) {
    console.error("Erreur lors de la récupération des données Pokémon:", error);
    return {
      notFound: true,
    };
  }
}

export default HomePage;
